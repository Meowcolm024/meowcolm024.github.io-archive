{"meta":{"title":"Meowcolm024","subtitle":"A personal blog of Meowcolm","description":null,"author":"Malcolm Law","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-11-25T10:58:31.000Z","updated":"2018-12-02T02:35:13.355Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I‚Äôm just a student trying to learn something like C++. But anime like the Fate series, the Garden of Sinners and Violet Evergarden are also fantastic. Well, I actually have no idea about what to write in the page orz."}],"posts":[{"title":"Pythagorean Triples","slug":"Pythagorean-Triples","date":"2018-12-16T10:34:45.000Z","updated":"2018-12-16T10:38:49.771Z","comments":true,"path":"2018/12/16/Pythagorean-Triples/","link":"","permalink":"http://yoursite.com/2018/12/16/Pythagorean-Triples/","excerpt":"","text":"It is really insteresting that only using one line of Haskell code could create a list of Pythagorean Triples. Copy and paste it to GHCi üòÉ 1[((p^2 - q^2),(2*p*q), sqrt((p^2 - q^2)^2 + (2*p*q)^2)) | p &lt;- [1..5], q &lt;- [1..5], p &gt; q]","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"}]},{"title":"FGO Script","slug":"FGO-Script","date":"2018-12-02T02:41:52.000Z","updated":"2018-12-02T03:53:31.047Z","comments":true,"path":"2018/12/02/FGO-Script/","link":"","permalink":"http://yoursite.com/2018/12/02/FGO-Script/","excerpt":"","text":"Thinking in the Script of Fate/GO Background I‚Äôm not gonna talk much about the background since everyone who plays this game konws that it‚Äôs a really a time-consuming game. What is more, the player need to repetitive actions which are meaningless. Thus, a script is necessary to complete these tasks. The main thinking There are approximately five parts I would like to cover: Order Card recognizing Servant recognizing Attack calculation AP recognition &amp; Interface recognition Holy Phantasms detection Order Card recognizing This is the most basic part of the script(and the Attack calculation part is also essential). The parts circled are the parts we need to detect(obviously). So first is the type of the card, which are Quick, Arts and Buster (the Extra Attack is speical so we would cover that later in the Servant recognizing part). To achieve this, we could the OpenCV library in Python(Yes, we are going to use Python this time üòÉ) and there is a funtion in the library call matchTemplate(), which could match a template with a image and produce a matix showing the how much is template is similar to the image in certain location. Knowing that, we could start working. First, we should ervery Order Card as an Object, since finally we need to choose 3 of them out of 5(ignoring the Holy Phantasms card). There is a way to match necessary information to the card: We could split the interface into five pieces with each piece contain only ONE Order Card. Then we could match the card type, the card state and the servant(Servant recognition is actually much more complicated) into each card separately. With the matchTemplate() function metioned above, we could complete it easily, and taht is the Order Card recognizing part done. Servant recognizing Well this is a really tricky part. Because of the fact that all servants would not appear at the first turn in most cases, and it is impossible to make templates for every servant in the game, we need to find a way to solve that. And here is the idea that I came up with: We could create the templates from the screenshot(or the interface) itself. As the location of the portrait of the servant on the card is fixed, and each servant has his/hers/its own portrait, we could just cut the portrait of each servant out and create templates using them. However, we might create repeated templates which need to be deleted. With just a few loops(since we do concern about efficiency) can we achieve our target. Then we just need the match the information into the Order Card. So the Servant recognizing part done.(But realizing it using Python is not as easy as I have written here QAQ) Attack calculation It is known that if we arrange the same set of cards differently, we would get different attack(I would like to call it Attack Index ==). Although different servents have different Attack Index, we just ignore that in order to make the script simple. So we just need to consider the arrangement of the cards we have. The image is the Rule of the aclculation of Attack Index Remember that we have already known about the servant, the card type, the card state when we completed the previous steps, we noe can make them into practice. The only thing we need to do is to follow the rule and write an alogrithm based on chart above, just some multiplications right? (so we focusing on whether the script could rather than whether it is effective or not orz) Though Holy Phantasms card have not been included yet, we shall talk about taht later. But for the Attack calculation part, it is done. AP recognition &amp; Interface recognition This part is quite important actually. But it is also a easy part due to the fact that we have completed the most difficult parts. Most of this part is just matching templates and getting coordinates. We also need to recover AP when it is insufficient. As for how many Gloden Apples need to be eaten, it depends on the player. It is still a quite an easy part, right? Holy Phantasms detection We know that every servant has a unique Holy Phantasms with its own name. In order to detect that, we need to use the template of the servant instead of the template of the order card. But we still need something the facilitate us, since we do not want to release every turn. So we need to mke use of Tesseract. This is a OCR library to recognize texts and we will used it to detect turns. Through this, we could release the Holy Phantasms at the certain turn(the FATAL BATTLE for example). Some minor things If you have read the codes, we may find out that the script also support different ‚Äúmodes‚Äù. They are desigened to optimize the performace your party, like Arts Mode etc. Each mode has its own characteristic, for example, in Arts Mode, the script would select 3 Arts cards if possible, instead of choosing the arrangement with highest Attack Index, but in the circumstance that there are less than 3 Arts cards the script would perform like the Default Mode which means that it would chooe the arrangement with highest Attack Index. Also the player himself/herself need to make a template for the checkpoint to inform the script of which checkpoint need to be chose. And Support Servants would be chose randomly XD! The end You can checkout the source code in GitHub üòÉ. And also two articles written in Chinese: 1, 2.","categories":[{"name":"Fate","slug":"Fate","permalink":"http://yoursite.com/categories/Fate/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Calculating Pi","slug":"Calculating-Pi","date":"2018-12-01T13:12:37.000Z","updated":"2018-12-02T02:40:38.111Z","comments":true,"path":"2018/12/01/Calculating-Pi/","link":"","permalink":"http://yoursite.com/2018/12/01/Calculating-Pi/","excerpt":"","text":"Calculating œÄ Well there is a really easy way to calculate œÄ using C++(or any other programming language actually‚Ä¶) And here is a simple programme used to calculate œÄ üòÉ The algorithm is actually based on the Leibniz formula for œÄ 12345678int main()&#123; double pie = 1.0; for(int i = 2; i &lt; 1000000; i++) pie = pie+(-1+2*(i%2))*(1/static_cast&lt;double&gt;(2*i-1)); cout &lt;&lt; \"pi: \" &lt;&lt; pie * 4 &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Merge Sort","slug":"Merge-Sort","date":"2018-12-01T07:18:18.000Z","updated":"2018-12-01T07:19:29.335Z","comments":true,"path":"2018/12/01/Merge-Sort/","link":"","permalink":"http://yoursite.com/2018/12/01/Merge-Sort/","excerpt":"","text":"Merge Sort Well, testing pictures XD","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://yoursite.com/categories/Alogrithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Insertion Sort","slug":"Insertion-Sort","date":"2018-11-29T14:22:39.000Z","updated":"2018-11-30T14:24:58.610Z","comments":true,"path":"2018/11/29/Insertion-Sort/","link":"","permalink":"http://yoursite.com/2018/11/29/Insertion-Sort/","excerpt":"","text":"Insertion Sort Well this article is for testing codes üòÉ Here is the code: 123456789101112131415void sort(int arr[], int len)&#123; int key, j; for (int i = 1; i &lt; len; i++) &#123; key = arr[i]; j = i - 1; while ((j &gt; -1) &amp;&amp; (arr[j] &gt; key) ) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125;&#125;","categories":[{"name":"Alogrithm","slug":"Alogrithm","permalink":"http://yoursite.com/categories/Alogrithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"test","slug":"test","date":"2018-11-25T10:09:22.000Z","updated":"2018-11-25T10:09:47.806Z","comments":true,"path":"2018/11/25/test/","link":"","permalink":"http://yoursite.com/2018/11/25/test/","excerpt":"","text":"This article is only for testing.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-25T09:07:15.525Z","updated":"2018-11-25T09:07:15.526Z","comments":true,"path":"2018/11/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}