{"meta":{"title":"Meowcolm024","subtitle":"A personal blog of Meowcolm","description":null,"author":"Malcolm Law","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-11-25T10:58:31.000Z","updated":"2019-02-11T13:57:20.318Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I‚Äôm just a student trying to learn something like Java and Haskell. I‚Äôm also studying Princeton‚Äôs Algorithms 4th Edition, which is really a difficult job QAQ. But anime like the Fate series, the Garden of Sinners and Violet Evergarden are also fantastic. Well, I actually have no idea about what to write in the page orz."}],"posts":[{"title":"Reverse a linked list","slug":"Reverse-a-linked-list","date":"2019-04-20T12:17:09.000Z","updated":"2019-04-20T12:32:12.653Z","comments":true,"path":"2019/04/20/Reverse-a-linked-list/","link":"","permalink":"http://yoursite.com/2019/04/20/Reverse-a-linked-list/","excerpt":"","text":"This is recursive function of reversing a linked list üòÉ 123456789101112131415161718class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head.next == null) &#123;return head;&#125; ListNode x = reverseList(head.next); head.next = null; ListNode i = x; while (i.next != null) &#123; i = i.next;&#125; i.next = head; return x; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Functional Programming is elegant","slug":"Functional-Programming-is-elegant","date":"2019-03-09T12:17:20.000Z","updated":"2019-04-20T12:32:15.508Z","comments":true,"path":"2019/03/09/Functional-Programming-is-elegant/","link":"","permalink":"http://yoursite.com/2019/03/09/Functional-Programming-is-elegant/","excerpt":"","text":"Overview It is known that Quicksort is an efficient way to sort an array. The alogrithm mainly works like this: select a pivot point put all elements which are less than the pivot element to the left side of the pivot point, and put those larger than it to the right side use the same method to sort the two subarrays Or, you can check it out from the book Algorithms, the part of Quicksort is also available online, just check out frome here. Approach Let‚Äôs first see the traditional approach in an imperative language (Java): 123456789101112131415161718192021222324252627282930313233// quicksort the subarray from a[lo] to a[hi]private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); assert isSorted(a, lo, hi);&#125;// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]// and return the index j.private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; // find item on lo to swap while (less(a[++i], v)) &#123; if (i == hi) break; &#125; // find item on hi to swap while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] acts as sentinel &#125; // check if pointers cross if (i &gt;= j) break; exch(a, i, j); &#125; // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi] return j; &#125; However, one thing is that the code is a bit hard to undersatnd, right? So, let‚Äôs take a look at the functional approach of this algorithm: 123456quicksort :: (Ord a) =&gt; [a] -&gt; [a]quicksort [] = []quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort (filter (&gt;x) xs) in smallerSorted ++ [x] ++ biggerSorted Well, it is much clearer, right? If you cannot understand what this code (in Haskell) means, we could rewrite it in a C-style language (in Swift and Python, since they support higher order function): 12345678// in swiftfunc quicksort(_ arr : [Int]) -&gt; [Int] &#123; if arr.count &lt;= 1 &#123; return arr &#125; let pivot = arr[0] let smaller = arr.dropFirst().filter(&#123;(x : Int) -&gt; Bool in return x &lt; pivot&#125;) let bigger = arr.dropFirst().filter(&#123;(x : Int) -&gt; Bool in return x &gt;= pivot&#125;) return (quicksort(smaller) + [pivot] + quicksort(bigger))&#125; 12345678# in pythondef quicksort(arr): if len(arr) &lt;= 1: return arr pivot = arr[0] smaller = filter((lambda x: x &lt; pivot), arr[1:]) bigger = filter((lambda x: x &gt;= pivot), arr[1:]) return quicksort(list(smaller)) + [pivot] + quicksort(list(bigger)) You can see that the code is much shorter and easier to understand. And this method also doesn‚Äôt change the original array/list which is more secure. And programming in a functional way does not need to learn a functional programming language like Haskell or Scala. Actually, most modern language supports higher order function making progamming functionally possible (like Python, C#, Swift etc). So, functional programming is really elegant right?","categories":[{"name":"Functional Programming","slug":"Functional-Programming","permalink":"http://yoursite.com/categories/Functional-Programming/"}],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Euler 26 in Haskell","slug":"Euler-26-in-Haskell","date":"2019-02-11T13:28:07.000Z","updated":"2019-02-11T13:31:59.785Z","comments":true,"path":"2019/02/11/Euler-26-in-Haskell/","link":"","permalink":"http://yoursite.com/2019/02/11/Euler-26-in-Haskell/","excerpt":"","text":"Solving Euler 26 using Haskell It is really interesting to find ou that the length of the recurring cycle of the reciprocal is only realted to its greatest prime divisor, thus the problem can be transferred to a problem of finding the largest prime number which its reciprocal has the longest recurring cycle under 1,000. A question is also asked in Stack Overflow 12345678910111213-- Reciprocal cyclesisPrime :: Integer -&gt; BoolisPrime k | k &lt;= 1 = error \"Seriously?\" | otherwise = null [ x | x &lt;- [2..floor(sqrt(fromIntegral k))], k `mod` x == 0]lp = [x | x &lt;- [7..1000], isPrime x]s = map (\\n -&gt; head [x | x &lt;- [ceiling(logBase 10 (fromIntegral n))..], 10^x `mod` n == 1]) lpmain::IO()main = print $ maximum s -- however it only prints the length, just use `elemIndex` to find the d","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"}]},{"title":"Euler 15 in Haskell","slug":"Euler-15-in-Haskell","date":"2019-02-03T03:56:00.000Z","updated":"2019-02-03T04:00:39.360Z","comments":true,"path":"2019/02/03/Euler-15-in-Haskell/","link":"","permalink":"http://yoursite.com/2019/02/03/Euler-15-in-Haskell/","excerpt":"","text":"Solving Euler #15 in Haskell This is a efficient way to solve. See Problem. 1234567891011121314151617181920212223242526-- Lattice pathsimport Data.Listfindposition number = (\\(Just i)-&gt;i) . findIndex (==number)getposition number = head . drop numbercount :: [(Int, Int)] -&gt; [Int] -&gt; (Int,Int) -&gt; Intcount ps qs (x,y) | x == 0 || y == 0 = 1 | (0 &lt; y || 0 &lt; x) &amp;&amp; c1 &amp;&amp; c2 = getposition (findposition (x,y-1) ps) qs + getposition (findposition (x-1,y) ps) qs | (0 &lt; y || 0 &lt; x) &amp;&amp; c1 &amp;&amp; not c2 = getposition (findposition (x,y-1) ps) qs + count ps qs (x-1,y) | (0 &lt; y || 0 &lt; x) &amp;&amp; c2 &amp;&amp; not c1 = count ps qs (x,y-1) + getposition (findposition (x-1,y) ps) qs | otherwise = count ps qs (x-1,y) + count ps qs (x,y-1) where c1 = (x,y-1) `elem` ps c2 = (x-1,y) `elem` pslatt :: Int -&gt; Int -&gt; [Int] -&gt; [Int]latt m n xs | n &lt; m = latt m (n+1) q | otherwise = q where lp = [(x,y) | x &lt;- [1..n-1], y &lt;- [1..n-1]] p = [(x,y) | x &lt;- [1..n], y &lt;- [1..n]] q = map (count lp xs) pmain::IO()main = print (last (latt 20 1 []))","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"}]},{"title":"Learning Haskell","slug":"Learning-Haskell","date":"2019-01-29T11:53:24.000Z","updated":"2019-01-29T13:36:31.079Z","comments":true,"path":"2019/01/29/Learning-Haskell/","link":"","permalink":"http://yoursite.com/2019/01/29/Learning-Haskell/","excerpt":"","text":"Some simple Haskell functions here üòÉ Quick Sort 123456quicksort :: (Ord a) =&gt; [a] -&gt; [a]quicksort [] = []quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort (filter (&gt;x) xs) in smallerSorted ++ [x] ++ biggerSorted Fibonacci 12345fbci :: Int -&gt; Intfbci 0 = 0fbci 1 = 1fbci 2 = 1fbci xx = fbci (xx-1) + fbci (xx-2) A Traditional way to calculate GCD 123456mygcd :: Int -&gt; Int -&gt; Intmygcd x y | (p &gt; 0) &amp;&amp; (p /= y) = mygcd p y | (p &lt; 0) &amp;&amp; (p /= x) = mygcd (-p) x | otherwise = p where p = x - y A use of pattern matching 12345678910bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String bmiTell weight height | bmi &lt;= skinny = \"You're underweight, you emo, you!\" | bmi &lt;= normal = \"You're supposedly normal. Pffft, I bet you're ugly!\" | bmi &lt;= fat = \"You're fat! Lose some weight, fatty!\" | otherwise = \"You're a whale, congratulations!\" where bmi = weight / height ^ 2 skinny = 18.5 normal = 25.0 fat = 30.0 A interesting function 12345chain :: (Integral a) =&gt; a -&gt; [a] chain 1 = [1] chain n | even n = n:chain (n `div` 2) | odd n = n:chain (n*3 + 1)","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"}]},{"title":"Pythagorean Triples","slug":"Pythagorean-Triples","date":"2018-12-16T10:34:45.000Z","updated":"2019-01-29T11:50:52.118Z","comments":true,"path":"2018/12/16/Pythagorean-Triples/","link":"","permalink":"http://yoursite.com/2018/12/16/Pythagorean-Triples/","excerpt":"","text":"It is really insteresting that only using one line of Haskell code could create a list of Pythagorean Triples. Copy and paste it to GHCi üòÉ 1[((p^2 - q^2),(2*p*q), sqrt((p^2 - q^2)^2 + (2*p*q)^2)) | p &lt;- [1..5], q &lt;- [1..5], p &gt; q]","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://yoursite.com/tags/Haskell/"}]},{"title":"FGO Script","slug":"FGO-Script","date":"2018-12-02T02:41:52.000Z","updated":"2018-12-02T03:53:31.047Z","comments":true,"path":"2018/12/02/FGO-Script/","link":"","permalink":"http://yoursite.com/2018/12/02/FGO-Script/","excerpt":"","text":"Thinking in the Script of Fate/GO Background I‚Äôm not gonna talk much about the background since everyone who plays this game konws that it‚Äôs a really a time-consuming game. What is more, the player need to repetitive actions which are meaningless. Thus, a script is necessary to complete these tasks. The main thinking There are approximately five parts I would like to cover: Order Card recognizing Servant recognizing Attack calculation AP recognition &amp; Interface recognition Holy Phantasms detection Order Card recognizing This is the most basic part of the script(and the Attack calculation part is also essential). The parts circled are the parts we need to detect(obviously). So first is the type of the card, which are Quick, Arts and Buster (the Extra Attack is speical so we would cover that later in the Servant recognizing part). To achieve this, we could the OpenCV library in Python(Yes, we are going to use Python this time üòÉ) and there is a funtion in the library call matchTemplate(), which could match a template with a image and produce a matix showing the how much is template is similar to the image in certain location. Knowing that, we could start working. First, we should ervery Order Card as an Object, since finally we need to choose 3 of them out of 5(ignoring the Holy Phantasms card). There is a way to match necessary information to the card: We could split the interface into five pieces with each piece contain only ONE Order Card. Then we could match the card type, the card state and the servant(Servant recognition is actually much more complicated) into each card separately. With the matchTemplate() function metioned above, we could complete it easily, and taht is the Order Card recognizing part done. Servant recognizing Well this is a really tricky part. Because of the fact that all servants would not appear at the first turn in most cases, and it is impossible to make templates for every servant in the game, we need to find a way to solve that. And here is the idea that I came up with: We could create the templates from the screenshot(or the interface) itself. As the location of the portrait of the servant on the card is fixed, and each servant has his/hers/its own portrait, we could just cut the portrait of each servant out and create templates using them. However, we might create repeated templates which need to be deleted. With just a few loops(since we do concern about efficiency) can we achieve our target. Then we just need the match the information into the Order Card. So the Servant recognizing part done.(But realizing it using Python is not as easy as I have written here QAQ) Attack calculation It is known that if we arrange the same set of cards differently, we would get different attack(I would like to call it Attack Index ==). Although different servents have different Attack Index, we just ignore that in order to make the script simple. So we just need to consider the arrangement of the cards we have. The image is the Rule of the aclculation of Attack Index Remember that we have already known about the servant, the card type, the card state when we completed the previous steps, we noe can make them into practice. The only thing we need to do is to follow the rule and write an alogrithm based on chart above, just some multiplications right? (so we focusing on whether the script could rather than whether it is effective or not orz) Though Holy Phantasms card have not been included yet, we shall talk about taht later. But for the Attack calculation part, it is done. AP recognition &amp; Interface recognition This part is quite important actually. But it is also a easy part due to the fact that we have completed the most difficult parts. Most of this part is just matching templates and getting coordinates. We also need to recover AP when it is insufficient. As for how many Gloden Apples need to be eaten, it depends on the player. It is still a quite an easy part, right? Holy Phantasms detection We know that every servant has a unique Holy Phantasms with its own name. In order to detect that, we need to use the template of the servant instead of the template of the order card. But we still need something the facilitate us, since we do not want to release every turn. So we need to mke use of Tesseract. This is a OCR library to recognize texts and we will used it to detect turns. Through this, we could release the Holy Phantasms at the certain turn(the FATAL BATTLE for example). Some minor things If you have read the codes, we may find out that the script also support different ‚Äúmodes‚Äù. They are desigened to optimize the performace your party, like Arts Mode etc. Each mode has its own characteristic, for example, in Arts Mode, the script would select 3 Arts cards if possible, instead of choosing the arrangement with highest Attack Index, but in the circumstance that there are less than 3 Arts cards the script would perform like the Default Mode which means that it would chooe the arrangement with highest Attack Index. Also the player himself/herself need to make a template for the checkpoint to inform the script of which checkpoint need to be chose. And Support Servants would be chose randomly XD! The end You can checkout the source code in GitHub üòÉ. And also two articles written in Chinese: 1, 2.","categories":[{"name":"Fate","slug":"Fate","permalink":"http://yoursite.com/categories/Fate/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Calculating Pi","slug":"Calculating-Pi","date":"2018-12-01T13:12:37.000Z","updated":"2019-01-29T07:59:31.808Z","comments":true,"path":"2018/12/01/Calculating-Pi/","link":"","permalink":"http://yoursite.com/2018/12/01/Calculating-Pi/","excerpt":"","text":"Calculating œÄ Well there is a really easy way to calculate œÄ using C++(or any other programming language actually‚Ä¶) And here is a simple program used to calculate œÄ üòÉ The algorithm is actually based on the Leibniz formula for œÄ 12345678int main()&#123; double pie = 1.0; for(int i = 2; i &lt; 1000000; i++) pie = pie+(-1+2*(i%2))*(1/static_cast&lt;double&gt;(2*i-1)); cout &lt;&lt; \"pi: \" &lt;&lt; pie * 4 &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Merge Sort","slug":"Merge-Sort","date":"2018-12-01T07:18:18.000Z","updated":"2019-04-20T12:32:14.078Z","comments":true,"path":"2018/12/01/Merge-Sort/","link":"","permalink":"http://yoursite.com/2018/12/01/Merge-Sort/","excerpt":"","text":"Well, testing pictures XD","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Insertion Sort","slug":"Insertion-Sort","date":"2018-11-29T14:22:39.000Z","updated":"2019-04-20T12:32:07.966Z","comments":true,"path":"2018/11/29/Insertion-Sort/","link":"","permalink":"http://yoursite.com/2018/11/29/Insertion-Sort/","excerpt":"","text":"Well this article is for testing codes üòÉ Here is the code: 123456789101112131415void sort(int arr[], int len)&#123; int key, j; for (int i = 1; i &lt; len; i++) &#123; key = arr[i]; j = i - 1; while ((j &gt; -1) &amp;&amp; (arr[j] &gt; key) ) &#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"test","slug":"test","date":"2018-11-25T10:09:22.000Z","updated":"2019-01-29T11:50:00.428Z","comments":true,"path":"2018/11/25/test/","link":"","permalink":"http://yoursite.com/2018/11/25/test/","excerpt":"","text":"This article is only for testing. Testing extension here üòÉ","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-25T09:07:15.525Z","updated":"2018-11-25T09:07:15.526Z","comments":true,"path":"2018/11/25/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}